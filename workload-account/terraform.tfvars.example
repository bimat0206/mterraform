# -----------------------------------------------------------------------------
# Example Terraform variables for Workload Account
# Copy this file to dev.tfvars or prod.tfvars and customize values
# Usage: terraform plan -var-file=dev.tfvars
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# General configuration
# -----------------------------------------------------------------------------
region = "ap-southeast-1" # AWS region

# -----------------------------------------------------------------------------
# Naming convention
# -----------------------------------------------------------------------------
org_prefix  = "tsk"  # Organization prefix (e.g., company abbreviation)
environment = "dev"  # Environment: dev, prod, staging, etc.
workload    = "app"  # Workload type: app, platform, data, etc.

# -----------------------------------------------------------------------------
# Tagging
# Standard tags applied to all resources via module tags + provider default_tags
# -----------------------------------------------------------------------------
tags = {
  owner       = "cloud-platform"  # Team or individual owner
  cost-center = "CC-1234"         # Cost allocation code
  project     = "landing-zone"    # Project name
  environment = "dev"             # Environment (redundant with provider default_tags but useful)
}

# -----------------------------------------------------------------------------
# Network Configuration (from Network Account)
# Import these values from network account remote state or provide directly
# -----------------------------------------------------------------------------
vpc_id             = "vpc-0123456789abcdef"     # VPC ID from network account
private_subnet_ids = ["subnet-abc", "subnet-def"] # Private subnet IDs
public_subnet_ids  = ["subnet-xyz", "subnet-uvw"] # Public subnet IDs

# Alternative: Use remote state data source (recommended)
# data "terraform_remote_state" "network" {
#   backend = "s3"
#   config = {
#     bucket = "your-terraform-state-bucket"
#     key    = "network-account/terraform.tfstate"
#     region = "ap-southeast-1"
#   }
# }
# Then reference: data.terraform_remote_state.network.outputs.vpc_id

# -----------------------------------------------------------------------------
# Key Pair Configuration
# Automatically create and store key pairs in Secrets Manager
# Cost: $0.40 per secret per month
# -----------------------------------------------------------------------------

# Option 1: Create new key pairs with Secrets Manager (RECOMMENDED)
# create_keypair_linux   = true
# create_keypair_windows = true
# keypair_algorithm      = "RSA"  # RSA, ECDSA, or ED25519
# keypair_rsa_bits       = 4096   # 2048 or 4096
# keypair_store_in_secretsmanager = true
# keypair_secret_recovery_window  = 30  # 7-30 days

# Optional: Use custom KMS key for secret encryption
# keypair_kms_key_id = "arn:aws:kms:region:account:key/12345678-..."

# Option 2: Use existing key pairs
# ec2_linux_existing_key_name   = "my-existing-linux-key"
# ec2_windows_existing_key_name = "my-existing-windows-key"

# -----------------------------------------------------------------------------
# EC2 Linux Configuration
# Set ec2_linux_enabled = true to create Linux EC2 instance
# Cost: t3.micro ~$8.47/month (Free tier eligible)
# Key Pair Cost: $0.40/month (if created with keypair module)
# -----------------------------------------------------------------------------
ec2_linux_enabled = false # Set to true to enable Linux EC2 instance

# Uncomment and configure if ec2_linux_enabled = true

# Basic Configuration
# ec2_linux_instance_type = "t3.micro"  # Instance type (t3.micro, t3.small, t3.medium, etc.)
# ec2_linux_ami_id        = ""          # Leave empty for auto-discovery (Amazon Linux 2023)
# ec2_linux_key_name      = "my-keypair" # EC2 key pair for SSH access
# ec2_linux_monitoring    = false       # Enable detailed monitoring ($2.10/month)

# Network Configuration
# ec2_linux_associate_public_ip = false  # true = public subnet, false = private subnet

# Storage Configuration
# ec2_linux_root_volume_size = 20  # Root volume size in GB

# IAM Configuration
# ec2_linux_create_iam_profile = true  # Create IAM instance profile with SSM

# Security Group Rules
# ec2_linux_security_group_ingress_rules = [
#   {
#     from_port   = 22
#     to_port     = 22
#     protocol    = "tcp"
#     cidr_blocks = ["10.0.0.0/8"]  # Restrict to VPC or specific CIDR
#     description = "SSH from VPC"
#   }
# ]

# User Data - Example: Install and configure web server
# ec2_linux_user_data = <<-EOT
#   #!/bin/bash
#   yum update -y
#   yum install -y nginx
#   systemctl start nginx
#   systemctl enable nginx
#   echo "Hello from $(hostname)" > /usr/share/nginx/html/index.html
# EOT

# -----------------------------------------------------------------------------
# EC2 Windows Configuration
# Set ec2_windows_enabled = true to create Windows EC2 instance
# Cost: t3.medium ~$34.94/month (minimum recommended for Windows)
# -----------------------------------------------------------------------------
ec2_windows_enabled = false # Set to true to enable Windows EC2 instance

# Uncomment and configure if ec2_windows_enabled = true

# Basic Configuration
# ec2_windows_instance_type = "t3.medium"  # Instance type (minimum t3.medium for Windows)
# ec2_windows_ami_id        = ""           # Leave empty for auto-discovery (Windows Server 2022)
# ec2_windows_key_name      = "my-keypair" # EC2 key pair for password retrieval
# ec2_windows_monitoring    = false        # Enable detailed monitoring ($2.10/month)

# Windows-Specific Configuration
# ec2_windows_get_password_data = false  # Retrieve Windows administrator password (requires key_name)

# Network Configuration
# ec2_windows_associate_public_ip = false  # true = public subnet, false = private subnet

# Storage Configuration
# ec2_windows_root_volume_size = 50  # Root volume size in GB (minimum 50GB recommended)

# IAM Configuration
# ec2_windows_create_iam_profile = true  # Create IAM instance profile with SSM

# Security Group Rules
# ec2_windows_security_group_ingress_rules = [
#   {
#     from_port   = 3389
#     to_port     = 3389
#     protocol    = "tcp"
#     cidr_blocks = ["10.0.0.0/8"]  # Restrict to VPC or specific CIDR
#     description = "RDP from VPC"
#   },
#   {
#     from_port   = 5985
#     to_port     = 5986
#     protocol    = "tcp"
#     cidr_blocks = ["10.0.0.0/8"]
#     description = "WinRM from VPC"
#   }
# ]

# User Data - Example: Install IIS and configure
# ec2_windows_user_data = <<-EOT
#   <powershell>
#   # Install IIS
#   Install-WindowsFeature -name Web-Server -IncludeManagementTools
#
#   # Configure application
#   New-Item -Path "C:\webapp" -ItemType Directory
#   Set-Content -Path "C:\webapp\index.html" -Value "Hello from Windows Server"
#
#   # Start IIS
#   Start-Service W3SVC
#   </powershell>
# EOT

# -----------------------------------------------------------------------------
# Example Configurations by Use Case
# -----------------------------------------------------------------------------

# Use Case 1: Linux with Auto-Generated Key Pair (RECOMMENDED)
# create_keypair_linux    = true
# ec2_linux_enabled       = true
# ec2_linux_instance_type = "t3.micro"
# ec2_linux_associate_public_ip = false
# ec2_linux_create_iam_profile = true
# After deployment, retrieve key:
# aws secretsmanager get-secret-value --secret-id tsk-dev-app-linux-01-private-key \
#   --query SecretString --output text | jq -r '.private_key' > keypair.pem && chmod 400 keypair.pem

# Use Case 2: Linux Web Server (Public)
# ec2_linux_enabled           = true
# ec2_linux_instance_type     = "t3.small"
# ec2_linux_key_name          = "my-keypair"
# ec2_linux_associate_public_ip = true
# ec2_linux_user_data = <<-EOT
#   #!/bin/bash
#   yum update -y
#   yum install -y nginx
#   systemctl start nginx
#   systemctl enable nginx
# EOT
# ec2_linux_security_group_ingress_rules = [
#   {
#     from_port   = 22
#     to_port     = 22
#     protocol    = "tcp"
#     cidr_blocks = ["203.0.113.0/24"]
#     description = "SSH from office"
#   },
#   {
#     from_port   = 80
#     to_port     = 80
#     protocol    = "tcp"
#     cidr_blocks = ["0.0.0.0/0"]
#     description = "HTTP from anywhere"
#   },
#   {
#     from_port   = 443
#     to_port     = 443
#     protocol    = "tcp"
#     cidr_blocks = ["0.0.0.0/0"]
#     description = "HTTPS from anywhere"
#   }
# ]

# Use Case 2: Linux App Server (Private, SSM only)
# ec2_linux_enabled           = true
# ec2_linux_instance_type     = "t3.micro"
# ec2_linux_associate_public_ip = false
# ec2_linux_create_iam_profile = true
# ec2_linux_security_group_ingress_rules = []  # No inbound, SSM uses outbound only

# Use Case 3: Windows App Server (Private, SSM only)
# ec2_windows_enabled           = true
# ec2_windows_instance_type     = "t3.medium"
# ec2_windows_associate_public_ip = false
# ec2_windows_create_iam_profile = true
# ec2_windows_security_group_ingress_rules = []  # No inbound, SSM uses outbound only

# Use Case 4: Windows Jump Host (Public, RDP access)
# ec2_windows_enabled           = true
# ec2_windows_instance_type     = "t3.medium"
# ec2_windows_key_name          = "my-keypair"
# ec2_windows_get_password_data = true
# ec2_windows_associate_public_ip = true
# ec2_windows_security_group_ingress_rules = [
#   {
#     from_port   = 3389
#     to_port     = 3389
#     protocol    = "tcp"
#     cidr_blocks = ["203.0.113.0/24"]
#     description = "RDP from office only"
#   }
# ]

# Use Case 5: Both Linux and Windows (Mixed Environment)
# ec2_linux_enabled   = true
# ec2_windows_enabled = true
# ec2_linux_instance_type   = "t3.small"
# ec2_windows_instance_type = "t3.medium"
# Both instances in private subnets with SSM access
# ec2_linux_associate_public_ip   = false
# ec2_windows_associate_public_ip = false

# -----------------------------------------------------------------------------
# Cost Estimation
# -----------------------------------------------------------------------------
# Linux (t3.micro):   ~$8.47/month + storage ($0.092/GB-month)
# Linux (t3.small):   ~$16.94/month + storage
# Linux (t3.medium):  ~$33.87/month + storage
# Windows (t3.medium): ~$34.94/month + storage
# Windows (t3.large):  ~$69.89/month + storage
# Storage (gp3, 20GB): ~$1.84/month (Linux)
# Storage (gp3, 50GB): ~$4.60/month (Windows)
# Monitoring (optional): $2.10/instance/month

# -----------------------------------------------------------------------------
# Security Best Practices
# -----------------------------------------------------------------------------
# 1. Use private subnets for application servers
# 2. Restrict security group CIDR blocks to known IPs
# 3. Use SSM Session Manager instead of SSH/RDP when possible
# 4. Enable IAM instance profiles for AWS service access
# 5. Do not embed credentials in user data scripts
# 6. Use encrypted EBS volumes (enabled by default)
# 7. Enable termination protection for production instances
# 8. Regularly apply OS security patches
# 9. Use bastion hosts or VPN for remote access
# 10. Implement proper logging and monitoring

# -----------------------------------------------------------------------------
# Remote State Import Example
# -----------------------------------------------------------------------------
# To import network account state, add data source to main.tf:
#
# data "terraform_remote_state" "network" {
#   backend = "s3"
#   config = {
#     bucket = "your-terraform-state-bucket"
#     key    = "network-account/terraform.tfstate"
#     region = "ap-southeast-1"
#   }
# }
#
# Then use in variables:
# vpc_id             = data.terraform_remote_state.network.outputs.vpc_id
# private_subnet_ids = data.terraform_remote_state.network.outputs.private_subnet_ids
# public_subnet_ids  = data.terraform_remote_state.network.outputs.public_subnet_ids

# -----------------------------------------------------------------------------
# RDS PostgreSQL Configuration
# Set rds_postgresql_enabled = true to create PostgreSQL RDS instance
# Cost: db.t3.micro ~$15/month (Single-AZ), ~$30/month (Multi-AZ)
# Storage: gp3 ~$0.092/GB-month
# -----------------------------------------------------------------------------
rds_postgresql_enabled = false # Set to true to enable PostgreSQL RDS

# Uncomment and configure if rds_postgresql_enabled = true

# Basic PostgreSQL Configuration
# rds_postgresql_instance_class    = "db.t3.micro"  # db.t3.micro, db.t3.small, db.r6g.large
# rds_postgresql_engine_version    = "16.1"         # 15.x, 16.x
# rds_postgresql_allocated_storage = 20             # GB
# rds_postgresql_database_name     = "myapp"        # Initial database name
# rds_postgresql_master_username   = "postgres"     # Master username

# High Availability
# rds_postgresql_multi_az = false  # true for production (2x cost)

# Backup
# rds_postgresql_backup_retention_period = 7  # Days (0-35)

# Security
# rds_postgresql_allowed_cidr_blocks = ["10.0.0.0/8"]  # VPC CIDR
# rds_postgresql_deletion_protection = false  # Enable for production

# After deployment, retrieve password:
# terraform output rds_postgresql_retrieve_password_command

# -----------------------------------------------------------------------------
# RDS MySQL Configuration
# Set rds_mysql_enabled = true to create MySQL RDS instance
# Cost: db.t3.micro ~$15/month (Single-AZ), ~$30/month (Multi-AZ)
# Storage: gp3 ~$0.092/GB-month
# -----------------------------------------------------------------------------
rds_mysql_enabled = false # Set to true to enable MySQL RDS

# Uncomment and configure if rds_mysql_enabled = true

# Basic MySQL Configuration
# rds_mysql_instance_class    = "db.t3.micro"  # db.t3.micro, db.t3.small, db.r6g.large
# rds_mysql_engine_version    = "8.0.35"       # 8.0.x, 5.7.x
# rds_mysql_allocated_storage = 20             # GB
# rds_mysql_database_name     = "myapp"        # Initial database name
# rds_mysql_master_username   = "admin"        # Master username

# High Availability
# rds_mysql_multi_az = false  # true for production (2x cost)

# Backup
# rds_mysql_backup_retention_period = 7  # Days (0-35)

# Security
# rds_mysql_allowed_cidr_blocks = ["10.0.0.0/8"]  # VPC CIDR
# rds_mysql_deletion_protection = false  # Enable for production

# After deployment, retrieve password:
# terraform output rds_mysql_retrieve_connection_info_command

# -----------------------------------------------------------------------------
# RDS SQL Server Configuration
# -----------------------------------------------------------------------------
# rds_sqlserver_enabled = true

# Edition Selection
# rds_sqlserver_engine = "sqlserver-se"  # sqlserver-ee (Enterprise), sqlserver-se (Standard),
#                                         # sqlserver-ex (Express), sqlserver-web (Web)

# Basic SQL Server Configuration
# rds_sqlserver_instance_class    = "db.t3.xlarge"        # Minimum for SE/EE
# rds_sqlserver_engine_version    = "15.00.4335.1.v1"     # 15.00 (2019), 16.00 (2022)
# rds_sqlserver_allocated_storage = 100                   # GB (minimum 20)
# rds_sqlserver_database_name     = "myapp"               # Optional initial database
# rds_sqlserver_master_username   = "sqladmin"            # Cannot be admin, sa, root

# High Availability
# rds_sqlserver_multi_az = false  # Not supported for Express/Web editions

# Backup
# rds_sqlserver_backup_retention_period = 7  # Days (0-35)

# Security
# rds_sqlserver_allowed_cidr_blocks = ["10.0.0.0/8"]  # VPC CIDR
# rds_sqlserver_deletion_protection = false  # Enable for production

# After deployment, retrieve connection info:
# terraform output rds_sqlserver_retrieve_connection_info_command

# -----------------------------------------------------------------------------
# Example: Full Application Stack
# -----------------------------------------------------------------------------
# Linux app server + PostgreSQL database
# ec2_linux_enabled      = true
# rds_postgresql_enabled = true
# rds_postgresql_allowed_cidr_blocks = ["10.0.0.0/8"]

# Windows app server + MySQL database
# ec2_windows_enabled = true
# rds_mysql_enabled   = true
# rds_mysql_allowed_cidr_blocks = ["10.0.0.0/8"]

# Windows app server + SQL Server database
# ec2_windows_enabled    = true
# rds_sqlserver_enabled  = true
# rds_sqlserver_engine   = "sqlserver-ex"  # Use Express for dev/test
# rds_sqlserver_allowed_cidr_blocks = ["10.0.0.0/8"]

# -----------------------------------------------------------------------------
# RDS Cost Estimation
# -----------------------------------------------------------------------------
# PostgreSQL/MySQL Pricing:
# db.t3.micro:  ~$15/month (Single-AZ), ~$30/month (Multi-AZ)
# db.t3.small:  ~$30/month (Single-AZ), ~$60/month (Multi-AZ)
# db.t3.medium: ~$61/month (Single-AZ), ~$122/month (Multi-AZ)
# db.r6g.large: ~$146/month (Single-AZ), ~$292/month (Multi-AZ)
#
# SQL Server Pricing (license-included):
# Express:     ~$50/month (db.t3.xlarge, Single-AZ)
# Web:         ~$100/month (db.t3.xlarge, Single-AZ)
# Standard:    ~$200/month (db.t3.xlarge, Single-AZ), ~$400/month (Multi-AZ)
# Enterprise:  ~$1,000+/month (depends on instance size)
#
# Storage (gp3): ~$0.092/GB-month
# Backup Storage: $0.095/GB-month (after free tier)
# Performance Insights: Free (7 days retention)
# Enhanced Monitoring: Included in RDS price
#
# Examples:
# - PostgreSQL: db.t3.micro + 20GB + Multi-AZ + Backups ≈ $32/month
# - SQL Server Express: db.t3.xlarge + 100GB ≈ $60/month
# - SQL Server Standard: db.t3.xlarge + 100GB + Multi-AZ ≈ $410/month

# -----------------------------------------------------------------------------
# EKS Configuration
# -----------------------------------------------------------------------------
# Enable EKS cluster
# eks_enabled = true
# eks_service_name = "eks"
# eks_identifier = "01"

# Cluster Configuration
# eks_kubernetes_version = "1.28"
# eks_cluster_endpoint_public_access = true
# eks_cluster_endpoint_private_access = true
# eks_cluster_endpoint_public_access_cidrs = ["0.0.0.0/0"]  # Restrict in production

# Logging (all enabled by default)
# eks_enabled_cluster_log_types = ["api", "audit", "authenticator", "controllerManager", "scheduler"]
# eks_cluster_log_retention_days = 7

# Encryption
# eks_enable_cluster_encryption = true

# Node Groups - Basic
# eks_node_groups = {
#   general = {
#     instance_types = ["t3.xlarge"]
#     desired_size   = 2
#     min_size       = 1
#     max_size       = 4
#     capacity_type  = "ON_DEMAND"
#     disk_size      = 50
#     labels         = {}
#     taints         = []
#   }
# }

# Node Groups - Multiple with Taints
# eks_node_groups = {
#   general = {
#     instance_types = ["t3.xlarge"]
#     desired_size   = 3
#     min_size       = 2
#     max_size       = 6
#     capacity_type  = "ON_DEMAND"
#     disk_size      = 100
#     labels = {
#       role = "general"
#     }
#     taints = []
#   }
#   compute = {
#     instance_types = ["c6i.2xlarge"]
#     desired_size   = 2
#     min_size       = 1
#     max_size       = 5
#     capacity_type  = "ON_DEMAND"
#     disk_size      = 100
#     labels = {
#       role = "compute"
#     }
#     taints = [
#       {
#         key    = "workload"
#         value  = "compute"
#         effect = "NoSchedule"
#       }
#     ]
#   }
#   spot = {
#     instance_types = ["t3.large", "t3a.large"]
#     desired_size   = 2
#     min_size       = 0
#     max_size       = 10
#     capacity_type  = "SPOT"
#     disk_size      = 50
#     labels = {
#       role = "spot"
#     }
#     taints = [
#       {
#         key    = "spot"
#         value  = "true"
#         effect = "NoSchedule"
#       }
#     ]
#   }
# }

# -----------------------------------------------------------------------------
# Fargate Profiles (Serverless Compute)
# -----------------------------------------------------------------------------
# Fargate profiles for serverless pod execution
# Note: Fargate requires private subnets

# Example: Basic Fargate profile for specific namespace
# eks_fargate_profiles = {
#   default = {
#     subnet_ids = var.private_subnet_ids  # Must use private subnets
#     selectors = [
#       {
#         namespace = "fargate-namespace"
#         labels    = {}
#       }
#     ]
#   }
# }

# Example: Multiple Fargate profiles for different workloads
# eks_fargate_profiles = {
#   # Fargate profile for game server workloads
#   game-server = {
#     subnet_ids = var.private_subnet_ids
#     selectors = [
#       {
#         namespace = "game-server"
#         labels = {
#           compute-type = "fargate"
#         }
#       }
#     ]
#     tags = {
#       Workload = "GameServer"
#     }
#   }
#
#   # Fargate profile for batch processing
#   batch = {
#     subnet_ids = var.private_subnet_ids
#     selectors = [
#       {
#         namespace = "batch-processing"
#         labels = {
#           compute-type = "fargate"
#         }
#       }
#     ]
#     tags = {
#       Workload = "Batch"
#     }
#   }
#
#   # Fargate profile for kube-system (CoreDNS)
#   kube-system = {
#     subnet_ids = var.private_subnet_ids
#     selectors = [
#       {
#         namespace = "kube-system"
#         labels = {
#           k8s-app = "kube-dns"
#         }
#       }
#     ]
#   }
# }

# Note: Pods matching Fargate selectors will run on Fargate instead of EC2 nodes
# To deploy pods on Fargate:
# 1. Create namespace: kubectl create namespace fargate-namespace
# 2. Deploy with matching labels: kubectl apply -f deployment.yaml -n fargate-namespace
# 3. Pods will automatically run on Fargate

# Fargate vs EC2 Nodes:
# - Fargate: Serverless, pay per pod, no node management, higher cost per vCPU/GB
# - EC2: Traditional nodes, pay per instance, lower cost at scale, more control
#
# Use Fargate for:
# - Intermittent workloads
# - Isolated workloads with specific security requirements
# - Workloads with unpredictable resource needs
# - Reduced operational overhead
#
# Use EC2 for:
# - Steady-state workloads
# - Cost-sensitive applications at scale
# - Workloads requiring specific instance types (GPU, high memory, etc.)
# - DaemonSets and node-level customizations

# Add-ons (all enabled by default)
# eks_enable_vpc_cni_addon = true
# eks_enable_coredns_addon = true
# eks_enable_kube_proxy_addon = true
# eks_enable_ebs_csi_driver_addon = true
# eks_enable_aws_load_balancer_controller = true

# IRSA (required for add-ons)
# eks_enable_irsa = true

# Container Insights
# eks_enable_container_insights = true
# eks_container_insights_log_retention_days = 7

# IAM Mapping - Roles
# eks_aws_auth_roles = [
#   {
#     rolearn  = "arn:aws:iam::123456789012:role/DevOps"
#     username = "devops"
#     groups   = ["system:masters"]
#   }
# ]

# IAM Mapping - Users
# eks_aws_auth_users = [
#   {
#     userarn  = "arn:aws:iam::123456789012:user/admin"
#     username = "admin"
#     groups   = ["system:masters"]
#   }
# ]

# IAM Mapping - Groups (via assumable roles)
# eks_map_iam_groups = {
#   developers = {
#     iam_group_arn = "arn:aws:iam::123456789012:group/Developers"
#     k8s_groups    = ["developers"]
#     k8s_username  = "{{SessionName}}"
#   }
#   readonly = {
#     iam_group_arn = "arn:aws:iam::123456789012:group/ReadOnly"
#     k8s_groups    = ["view-only"]
#   }
# }

# After deployment:
# 1. Configure kubectl:
#    terraform output eks_kubeconfig_command
#    
# 2. View control plane logs:
#    terraform output eks_view_cluster_logs_command
#    
# 3. View Container Insights:
#    terraform output eks_view_container_insights_command
#    
# 4. Create RBAC for developers group:
#    kubectl apply -f - <<EOF
#    apiVersion: rbac.authorization.k8s.io/v1
#    kind: ClusterRole
#    metadata:
#      name: developers
#    rules:
#      - apiGroups: ["", "apps", "batch"]
#        resources: ["*"]
#        verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
#    ---
#    apiVersion: rbac.authorization.k8s.io/v1
#    kind: ClusterRoleBinding
#    metadata:
#      name: developers
#    roleRef:
#      apiGroup: rbac.authorization.k8s.io
#      kind: ClusterRole
#      name: developers
#    subjects:
#      - kind: Group
#        name: developers
#    EOF

# -----------------------------------------------------------------------------
# EKS Cost Estimation
# -----------------------------------------------------------------------------
# EKS Control Plane: $73/month
# 
# Node Costs (per month, on-demand):
# t3.xlarge:    ~$120/month (4 vCPU, 16 GB RAM)
# c6i.2xlarge:  ~$246/month (8 vCPU, 16 GB RAM)
# r6i.xlarge:   ~$230/month (4 vCPU, 32 GB RAM)
# g4dn.xlarge:  ~$380/month (4 vCPU, 16 GB RAM, 1 GPU)
#
# Node Costs (per month, spot - 60-90% discount):
# t3.xlarge:    ~$35/month
# c6i.2xlarge:  ~$75/month
#
# EBS Storage (gp3): ~$0.08/GB-month
# Data Transfer: $0.09/GB (outbound)
# CloudWatch Logs: $0.50/GB ingested, $0.03/GB stored
# Container Insights: Included in CloudWatch Logs pricing
#
# Examples:
# Small cluster: 
#   Control Plane ($73) + 2x t3.xlarge ($240) + 200GB storage ($16) 
#   = ~$329/month
#
# Medium cluster: 
#   Control Plane ($73) + 3x t3.xlarge ($360) + 2x c6i.2xlarge ($492) + 500GB storage ($40) 
#   = ~$965/month
#
# Cost-optimized with Spot:
#   Control Plane ($73) + 2x t3.xlarge ON_DEMAND ($240) + 3x t3.xlarge SPOT ($105) + 300GB storage ($24)
#   = ~$442/month (42% cheaper than all on-demand)
#
# Tips:
# - Use Spot instances for fault-tolerant workloads (60-90% savings)
# - Enable cluster autoscaler to scale nodes based on demand
# - Use smaller instance types and scale horizontally
# - Reduce log retention for non-production (7 days vs 30 days)
# - Use Fargate for serverless containers (pay per pod)

# -----------------------------------------------------------------------------
# ECR (Elastic Container Registry) Configuration
# -----------------------------------------------------------------------------
# Enable ECR module to create private container registries
ecr_enabled = false

# ECR Repositories
# ecr_repositories = {
#   backend = {
#     image_tag_mutability = "IMMUTABLE"  # Tags cannot be overwritten (recommended for prod)
#     scan_on_push         = true         # Scan images for vulnerabilities on push
#     encryption_type      = "AES256"     # or "KMS" with kms_key_arn
#
#     lifecycle_policy = {
#       max_image_count        = 30      # Keep only 30 most recent images
#       max_untagged_days      = 7       # Delete untagged images after 7 days
#       max_tagged_days        = 90      # Delete old tagged images after 90 days
#       protected_tags         = ["latest", "prod", "v*"]  # Never delete these
#       enable_untagged_expiry = true
#     }
#   }
#
#   frontend = {
#     image_tag_mutability = "MUTABLE"   # Allow tag overwrites (dev/staging)
#     scan_on_push         = true
#
#     lifecycle_policy = {
#       max_image_count   = 20
#       max_untagged_days = 3
#       max_tagged_days   = 60
#     }
#   }
#
#   api = {
#     scan_on_push    = true
#     encryption_type = "KMS"
#     kms_key_arn     = "arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012"
#   }
# }

# Enhanced Scanning (AWS Inspector - additional cost)
# ecr_enable_enhanced_scanning = true
# ecr_scan_frequency           = "CONTINUOUS_SCAN"  # or "SCAN_ON_PUSH", "MANUAL"

# Cross-Region Replication
# ecr_enable_replication = true
# ecr_replication_configuration = {
#   rules = [
#     {
#       destinations = [
#         {
#           region      = "us-west-2"
#           registry_id = "123456789012"
#         },
#         {
#           region      = "eu-west-1"
#           registry_id = "123456789012"
#         }
#       ]
#       repository_filters = [
#         {
#           filter      = "prod-*"
#           filter_type = "PREFIX_MATCH"
#         }
#       ]
#     }
#   ]
# }

# Pull Through Cache (cache public registries)
# ecr_enable_pull_through_cache = true
# ecr_pull_through_cache_rules = {
#   docker-hub = {
#     upstream_registry_url = "registry-1.docker.io"
#     credential_arn        = "arn:aws:secretsmanager:us-east-1:123456789012:secret:dockerhub-creds"
#   }
#   github = {
#     upstream_registry_url = "ghcr.io"
#   }
# }

# After deployment, use these commands:
# 1. Login to ECR:
#    terraform output ecr_docker_login_command
#
# 2. Build and push image:
#    docker build -t myapp:latest .
#    docker tag myapp:latest <ecr-url>/tsk-dev-workload-backend:latest
#    docker push <ecr-url>/tsk-dev-workload-backend:latest
#
# 3. View repositories:
#    aws ecr describe-repositories
#
# 4. Scan image:
#    aws ecr start-image-scan --repository-name <repo> --image-id imageTag=latest

# -----------------------------------------------------------------------------
# ECR Cost Estimation
# -----------------------------------------------------------------------------
# Storage: $0.10 per GB per month
# Data Transfer: Standard AWS rates
# Enhanced Scanning: ~$0.09 per image scan (first scan free)
#
# Example:
# 5 repositories × 10 images × 500 MB = 25 GB storage = $2.50/month
# Enhanced scanning: 50 images × $0.09 = ~$4.50/month
# Total: ~$7/month

# -----------------------------------------------------------------------------
# ECS (Elastic Container Service) Configuration
# -----------------------------------------------------------------------------
# Enable ECS module to create Fargate-based container services
ecs_enabled = false

# ECS Cluster Configuration
# ecs_cluster_name              = ""     # Defaults to: org-env-workload
# ecs_enable_container_insights = true   # Enable CloudWatch Container Insights
# ecs_enable_fargate            = true   # Enable Fargate capacity provider
# ecs_enable_fargate_spot       = false  # Enable Fargate Spot (70% cheaper)

# Capacity Provider Strategy (Fargate + Fargate Spot)
# ecs_default_capacity_provider_strategy = [
#   {
#     capacity_provider = "FARGATE_SPOT"
#     weight            = 4
#     base              = 0
#   },
#   {
#     capacity_provider = "FARGATE"
#     weight            = 1
#     base              = 1  # Always run at least 1 task on regular Fargate
#   }
# ]

# Task Definitions
# ecs_task_definitions = {
#   web-app = {
#     cpu    = "256"   # 0.25 vCPU
#     memory = "512"   # 512 MB
#
#     container_definitions = [
#       {
#         name  = "web"
#         image = "123456789012.dkr.ecr.us-east-1.amazonaws.com/tsk-dev-workload-backend:latest"
#
#         portMappings = [
#           {
#             containerPort = 8080
#             protocol      = "tcp"
#           }
#         ]
#
#         environment = [
#           { name = "ENV", value = "production" },
#           { name = "PORT", value = "8080" }
#         ]
#
#         secrets = [
#           {
#             name      = "DATABASE_URL"
#             valueFrom = "arn:aws:secretsmanager:us-east-1:123456789012:secret:db-url"
#           }
#         ]
#
#         healthCheck = {
#           command     = ["CMD-SHELL", "curl -f http://localhost:8080/health || exit 1"]
#           interval    = 30
#           timeout     = 5
#           retries     = 3
#           startPeriod = 60
#         }
#       }
#     ]
#
#     # Task role (application permissions)
#     task_role_policy_statements = [
#       {
#         effect    = "Allow"
#         actions   = ["s3:GetObject", "s3:PutObject"]
#         resources = ["arn:aws:s3:::my-bucket/*"]
#       }
#     ]
#   }
#
#   # Multi-container task with sidecar
#   api-with-sidecar = {
#     cpu    = "512"
#     memory = "1024"
#
#     container_definitions = [
#       {
#         name  = "api"
#         image = "myapi:latest"
#         portMappings = [{ containerPort = 3000 }]
#       },
#       {
#         name      = "log-router"
#         image     = "public.ecr.aws/aws-observability/aws-for-fluent-bit:latest"
#         essential = false
#       }
#     ]
#   }
# }

# ECS Services
# ecs_services = {
#   web-app = {
#     task_definition_key = "web-app"
#     desired_count       = 2
#
#     subnets         = var.private_subnet_ids
#     security_groups = ["sg-1234567890abcdef0"]
#
#     # ALB Integration
#     load_balancers = [
#       {
#         target_group_arn = "arn:aws:elasticloadbalancing:us-east-1:123456789012:targetgroup/my-tg/..."
#         container_name   = "web"
#         container_port   = 8080
#       }
#     ]
#
#     health_check_grace_period_seconds = 60
#
#     # Auto-scaling
#     autoscaling = {
#       min_capacity = 2
#       max_capacity = 10
#
#       target_tracking_policies = [
#         {
#           name              = "cpu-target-tracking"
#           target_value      = 70.0
#           predefined_metric = "ECSServiceAverageCPUUtilization"
#           scale_in_cooldown  = 300
#           scale_out_cooldown = 60
#         },
#         {
#           name              = "memory-target-tracking"
#           target_value      = 80.0
#           predefined_metric = "ECSServiceAverageMemoryUtilization"
#         }
#       ]
#     }
#   }
# }

# CloudWatch Logs
# ecs_create_cloudwatch_log_groups = true
# ecs_log_retention_in_days        = 7

# After deployment:
# 1. List services:
#    terraform output ecs_commands
#
# 2. View logs:
#    aws logs tail /ecs/<cluster-name>/<task-key> --follow
#
# 3. Update service (force new deployment):
#    aws ecs update-service --cluster <cluster> --service <service> --force-new-deployment
#
# 4. Execute command in container (if enable_execute_command = true):
#    aws ecs execute-command --cluster <cluster> --task <task-id> \
#      --container <container> --interactive --command "/bin/sh"

# -----------------------------------------------------------------------------
# ECS Fargate Task Sizes
# -----------------------------------------------------------------------------
# CPU (vCPU)  | Memory (GB)
# ------------|------------------
# 0.25        | 0.5, 1, 2
# 0.5         | 1, 2, 3, 4
# 1           | 2, 3, 4, 5, 6, 7, 8
# 2           | 4-16 (1 GB increments)
# 4           | 8-30 (1 GB increments)

# -----------------------------------------------------------------------------
# ECS Cost Estimation (Fargate, us-east-1)
# -----------------------------------------------------------------------------
# CPU: $0.04048 per vCPU per hour
# Memory: $0.004445 per GB per hour
#
# Examples (per task, per month):
# 0.25 vCPU + 0.5 GB  = ~$9/month
# 0.5 vCPU + 1 GB     = ~$18/month
# 1 vCPU + 2 GB       = ~$35/month
# 2 vCPU + 4 GB       = ~$70/month
#
# Fargate Spot (70% discount):
# 1 vCPU + 2 GB       = ~$10.50/month
#
# Example service (2-10 tasks with auto-scaling):
# Average 5 tasks × 1 vCPU + 2 GB = ~$175/month (Fargate)
# Average 5 tasks × 1 vCPU + 2 GB = ~$52/month (Fargate Spot)
#
# Additional costs:
# CloudWatch Logs: $0.50/GB ingested
# Container Insights: Included (no additional charge)
# Data Transfer: $0.09/GB (outbound)
# ALB: ~$16/month + $0.008 per LCU-hour
#
# Tips:
# - Use Fargate Spot for fault-tolerant workloads (70% savings)
# - Right-size tasks (don't over-provision CPU/memory)
# - Use auto-scaling to match demand
# - Set log retention to control CloudWatch costs
# - Use ECR lifecycle policies to reduce storage costs
